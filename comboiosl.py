# -*- coding: utf-8 -*-
import streamlit as st
import cv2
import numpy as np
import insightface
from insightface.app import FaceAnalysis
from scipy.spatial.distance import cosine
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

# Inicializar o modelo InsightFace
@st.cache_resource
def load_face_model():
    app = FaceAnalysis()
    app.prepare(ctx_id=0, det_size=(640, 640))
    return app

app = load_face_model()

# Fun√ß√µes auxiliares
def calculate_similarity(embedding1, embedding2):
    cos_distance = cosine(embedding1, embedding2)
    similarity = (1 - cos_distance) * 100
    similarity = max(min(similarity, 100), 0)
    return similarity

def extract_faces(image):
    """Extrai rostos com bounding boxes e embeddings"""
    img = cv2.imdecode(np.frombuffer(image.read(), np.uint8), cv2.IMREAD_COLOR)
    if img is None:
        return None
    
    faces = app.get(img)
    if not faces:
        return None
    
    # Desenhar bounding boxes na imagem
    img_with_boxes = img.copy()
    for face in faces:
        bbox = face.bbox.astype(int)
        cv2.rectangle(img_with_boxes, (bbox[0], bbox[1]), (bbox[2], bbox[3]), (0, 255, 0), 2)
    
    return {
        'image': img,
        'image_with_boxes': img_with_boxes,
        'faces': faces
    }

def plot_embeddings(embeddings, labels):
    """Visualiza embeddings em 2D e 3D usando PCA e t-SNE"""
    
    # Converter para numpy array
    embeddings = np.array(embeddings)
    
    # PCA 2D
    pca_2d = PCA(n_components=2)
    embeddings_pca_2d = pca_2d.fit_transform(embeddings)
    
    # t-SNE 2D
    tsne_2d = TSNE(n_components=2, perplexity=min(5, len(embeddings)-1))
    embeddings_tsne_2d = tsne_2d.fit_transform(embeddings)
    
    # Criar figuras
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    
    # Plot PCA 2D
    for i, (x, y) in enumerate(embeddings_pca_2d):
        ax1.scatter(x, y, label=labels[i])
        ax1.text(x, y, f"{i+1}", fontsize=12)
    ax1.set_title('PCA 2D')
    ax1.legend()
    
    # Plot t-SNE 2D
    for i, (x, y) in enumerate(embeddings_tsne_2d):
        ax2.scatter(x, y, label=labels[i])
        ax2.text(x, y, f"{i+1}", fontsize=12)
    ax2.set_title('t-SNE 2D')
    ax2.legend()
    
    st.pyplot(fig)
    
    # PCA 3D se tivermos pelo menos 3 pontos
    if len(embeddings) >= 3:
        fig_3d = plt.figure(figsize=(8, 6))
        ax_3d = fig_3d.add_subplot(111, projection='3d')
        
        pca_3d = PCA(n_components=3)
        embeddings_pca_3d = pca_3d.fit_transform(embeddings)
        
        for i, (x, y, z) in enumerate(embeddings_pca_3d):
            ax_3d.scatter(x, y, z, label=labels[i])
            ax_3d.text(x, y, z, f"{i+1}", fontsize=12)
        
        ax_3d.set_title('PCA 3D')
        ax_3d.legend()
        st.pyplot(fig_3d)

# Interface Streamlit
st.title("üîç Comparador Avan√ßado de Rostos")
st.write("""
Fa√ßa upload de duas imagens para comparar os rostos detectados. 
A aplica√ß√£o mostrar√°:
- Imagens com bounding boxes nos rostos detectados
- Similaridade entre os rostos
- Visualiza√ß√£o dos embeddings em 2D e 3D
""")

# Upload das imagens
col1, col2 = st.columns(2)
with col1:
    st.subheader("Imagem 1")
    img1 = st.file_uploader("Selecione a primeira imagem", type=["jpg", "jpeg", "png"], key="img1")

with col2:
    st.subheader("Imagem 2")
    img2 = st.file_uploader("Selecione a segunda imagem", type=["jpg", "jpeg", "png"], key="img2")

if img1 and img2:
    # Processar imagens
    result1 = extract_faces(img1)
    result2 = extract_faces(img2)
    
    if not result1 or not result2:
        st.error("N√£o foi poss√≠vel detectar rostos em uma ou ambas as imagens.")
    else:
        # Mostrar imagens com bounding boxes
        st.subheader("Rostos Detectados")
        col1, col2 = st.columns(2)
        with col1:
            st.image(cv2.cvtColor(result1['image_with_boxes'], cv2.COLOR_BGR2RGB), 
                    caption="Imagem 1 com rostos detectados", use_column_width=True)
        with col2:
            st.image(cv2.cvtColor(result2['image_with_boxes'], cv2.COLOR_BGR2RGB), 
                    caption="Imagem 2 com rostos detectados", use_column_width=True)
        
        # Comparar os primeiros rostos de cada imagem
        face1 = result1['faces'][0]
        face2 = result2['faces'][0]
        
        similarity = calculate_similarity(face1.embedding, face2.embedding)
        
        # Resultados da compara√ß√£o
        st.subheader("üìä Resultados da Compara√ß√£o")
        st.metric("Similaridade entre os rostos", f"{similarity:.2f}%")
        
        # Barra de similaridade
        st.progress(int(similarity))
        
        # Interpreta√ß√£o
        if similarity < 60.0:
            st.warning("üë§ As imagens N√ÉO s√£o da mesma pessoa (similaridade abaixo de 60.0%)")
        elif 60.0 <= similarity < 75.0:
            st.info("ü§î As imagens s√£o PROVAVELMENTE da mesma pessoa (similaridade entre 60.0% e 75.0%)")
        else:
            st.success("‚úÖ As imagens S√ÉO da mesma pessoa (similaridade acima de 75.0%)")
        
        # M√©tricas adicionais
        st.write(f"**Dist√¢ncia de cosseno:** {cosine(face1.embedding, face2.embedding):.4f}")
        
        # Visualiza√ß√£o dos embeddings
        st.subheader("üìà Visualiza√ß√£o dos Embeddings")
        
        embeddings = [face1.embedding, face2.embedding]
        labels = ["Imagem 1", "Imagem 2"]
        
        plot_embeddings(embeddings, labels)
        
        # Detalhes t√©cnicos
        with st.expander("üîç Detalhes t√©cnicos"):
            st.write("**Embedding da Imagem 1:**", face1.embedding)
            st.write("**Embedding da Imagem 2:**", face2.embedding)
            st.write("**Dimens√£o dos embeddings:**", len(face1.embedding))
            
            # Matriz de dist√¢ncia
            dist_matrix = np.zeros((2, 2))
            for i in range(2):
                for j in range(2):
                    dist_matrix[i, j] = cosine(embeddings[i], embeddings[j])
            
            st.write("**Matriz de dist√¢ncia de cosseno:**")
            st.dataframe(dist_matrix, index=labels, columns=labels)

# Rodap√©
st.markdown("---")
st.caption("Aplica√ß√£o desenvolvida usando InsightFace, Streamlit e t√©cnicas de redu√ß√£o de dimensionalidade")
Funcionalidades desta vers√£o:
Upload de duas imagens:

Interface simples para selecionar duas imagens do computador

Processamento em tempo real

Detec√ß√£o de rostos com bounding boxes:

Mostra as imagens originais com ret√¢ngulos verdes ao redor dos rostos detectados

Usa o detector do InsightFace para localiza√ß√£o precisa

An√°lise de similaridade:

Calcula a similaridade entre os rostos em porcentagem

Mostra a dist√¢ncia de cosseno entre os embeddings

Classifica√ß√£o em 3 categorias com feedback visual

Visualiza√ß√£o dos embeddings:

Gr√°ficos em segunda dimens√£o usando PCA e t-SNE

Gr√°fico 3D usando PCA (quando aplic√°vel)

R√≥tulos claros para cada ponto

Informa√ß√µes t√©cnicas:

Expans√≠vel com detalhes dos embeddings e matriz de dist√¢ncia

Como executar:
Salve o c√≥digo em um arquivo face_comparison.py

Instale as depend√™ncias:

pip install streamlit opencv-python numpy insightface scikit-learn matplotlib scipy
Execute com:

streamlit run face_comparison.py
Melhorias adicionais poss√≠veis:
Adicionar op√ß√£o para comparar m√∫ltiplos rostos na mesma imagem

Permitir ajuste dos limiares de similaridade

Adicionar anima√ß√µes durante o processamento

Op√ß√£o para salvar os resultados da compara√ß√£o

Visualiza√ß√£o mais interativa dos gr√°ficos 3D (usando Plotly)

Esta aplica√ß√£o fornece uma an√°lise completa da similaridade facial com visualiza√ß√µes intuitivas dos embeddings, mantendo a simplicidade de uso com apenas duas imagens de upload.

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from collections import Counter
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.utils import ImageReader
import re, os
from io import BytesIO

sns.set(style="darkgrid")

dias_semana = {
    "Monday": "Segunda-feira", "Tuesday": "Ter√ßa-feira", "Wednesday": "Quarta-feira",
    "Thursday": "Quinta-feira", "Friday": "Sexta-feira", "Saturday": "S√°bado", "Sunday": "Domingo"
}

def main():
    st.set_page_config(layout="wide")
    st.sidebar.title("Navega√ß√£o")
    pagina = st.sidebar.radio("Escolha uma op√ß√£o:", ["üöóüöó - Ve√≠culos em Comboio", "üïµÔ∏è - An√°lise de Passagens"])

    if pagina == "üöóüöó - Ve√≠culos em Comboio":
        veiculos_em_comboio()
    elif pagina == "üïµÔ∏è - An√°lise de Passagens":
        analise_de_passagens()


# -------------------------------------------
# P√°gina 1 ‚Äì Ve√≠culos em Comboio
# -------------------------------------------
def veiculos_em_comboio():
    import re
    from collections import defaultdict

    def process_text(text):
        linhas = [linha.strip() for linha in text.split("\n") if linha.strip()]
        placas = defaultdict(list)
        padrao_placa = re.compile(r'[A-Za-z]{3}\d[A-Za-z]\d{2}|[A-Za-z]{3}\d{4}')
        padrao_data_hora = re.compile(r'(\d{2}/\d{2}/\d{4})\s+(\d{2}:\d{2})')
        placa_atual = None

        for linha in linhas:
            if padrao_placa.fullmatch(linha.strip()):
                placa_atual = linha.strip().upper()
            elif placa_atual and (match := padrao_data_hora.search(linha)):
                data, hora = match.groups()
                placas[placa_atual].append(f"{data} {hora}")
        return placas

    def display_results(placas):
        resultado = "## RELAT√ìRIO DE PLACAS:\n\n"
        resultado += f"**Total de placas √∫nicas encontradas:** {len(placas)}\n\n"
        placas_unicas = {p: d for p, d in placas.items() if len(d) == 1}
        placas_repetidas = {p: d for p, d in placas.items() if len(d) > 1}

        if placas_repetidas:
            resultado += "### üö® PLACAS REPETIDAS:\n"
            for placa, registros in sorted(placas_repetidas.items()):
                resultado += f"\n**Placa:** {placa}\n**Quantidade:** {len(registros)} ocorr√™ncias\n**Registros:**\n"
                for registro in sorted(registros):
                    resultado += f"- {registro}\n"
        if placas_unicas:
            resultado += "\n\n### üîπ PLACAS √öNICAS (apareceram apenas uma vez):\n"
            for placa, registros in sorted(placas_unicas.items()):
                resultado += f"\n**Placa:** {placa}\n**Registro:** {registros[0]}\n"
        return resultado

    st.title("Ve√≠culos em Comboio")
    if 'text_blocks' not in st.session_state:
        st.session_state.text_blocks = [""]

    if st.button("‚ûï Adicionar Passagem"):
        st.session_state.text_blocks.append("")

    for i in range(len(st.session_state.text_blocks)):
        st.session_state.text_blocks[i] = st.text_area(
            f"Passagem {i + 1}",
            value=st.session_state.text_blocks[i],
            height=200,
            key=f"text_block_{i}"
        )

    if st.button("Processar"):
        full_text = "\n".join(st.session_state.text_blocks)
        if full_text.strip():
            placas = process_text(full_text)
            results = display_results(placas)
            st.markdown(results)
            st.download_button("‚¨áÔ∏è Baixar Relat√≥rio", data=results, file_name="relatorio_placas.txt", mime="text/plain")


# -------------------------------------------
# P√°gina 2 ‚Äì An√°lise de Passagens
# -------------------------------------------
def analise_de_passagens():
    st.title("An√°lise de Passagens")

    texto = st.text_area("Cole os dados (linha 1: placa, linha 2: t√≠tulo, restante: registros):", height=400)
    if st.button("Processar Registros"):
        if texto:
            processar_analise(texto)
        else:
            st.warning("Por favor, insira o texto antes de processar.")


def processar_analise(texto):
        # Adiciona "0/0" no final do texto se ainda n√£o estiver presente
    if not texto.strip().endswith("0/0"):
        texto = texto + "\n0/0"
    linhas = [linha.strip() for linha in texto.splitlines() if linha.strip()]
    if len(linhas) < 2:
        st.error("Texto deve conter pelo menos duas linhas: placa e t√≠tulo.")
        return

    placa = linhas[0].strip()
    titulo = linhas[1].strip()
    texto_limpo = "\n".join(linhas)

    padrao = re.compile(r'(\d{1,3})?\n?(\d{2}/\d{2}/\d{4})\s+(\d{2}:\d{2})\n([^\n]+)\n([^\n]+)', re.VERBOSE)
    registros = []

    for i, match in enumerate(padrao.finditer(texto_limpo)):
        velocidade, data, horario, local, _ = match.groups()
        cidade = local.split(',')[-1].split('-')[0].strip() if ',' in local and '-' in local else local
        data_formatada = datetime.strptime(data, "%d/%m/%Y")
        hora = int(horario.split(":")[0])
        turno = "Manh√£" if 0 <= hora < 12 else "Tarde" if hora < 18 else "Noite"
        dia_semana = dias_semana[data_formatada.strftime("%A")]
        intervalo = f"{hora}:00 - {hora+1}:00"
        registros.append([i + 1, velocidade or "", data, horario, turno, dia_semana, intervalo, local, cidade])

    if not registros:
        st.error("Nenhum registro v√°lido encontrado.")
        return

    df = pd.DataFrame(registros, columns=["Ord", "Velocidade", "Data", "Hor√°rio", "Turno", "Dia da Semana", "Intervalo", "Local", "Cidade"])
    st.success(f"{len(df)} registros processados.")
    st.dataframe(df)

    # Gera√ß√£o Excel
    excel_buffer = BytesIO()
    df.to_excel(excel_buffer, index=False)
    st.download_button("‚¨áÔ∏è Baixar Excel", data=excel_buffer.getvalue(), file_name=f"{placa}.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

    # Gera√ß√£o da an√°lise textual e PDF
    analise, imagens = gerar_analise(df, placa)
    st.markdown(analise)

    pdf_buffer = gerar_pdf_streamlit(df, placa, titulo, analise, imagens)
    st.download_button("‚¨áÔ∏è Baixar PDF", data=pdf_buffer.getvalue(), file_name=f"analise_{placa}.pdf", mime="application/pdf")


def gerar_analise(df, placa):
    analise = ""
    imagens = []
    contagem_turno = Counter(df["Turno"])
    contagem_horario = Counter(df["Intervalo"])
    contagem_dia = Counter(df["Dia da Semana"])
    contagem_local = Counter(df["Local"])

    dia_freq = contagem_dia.most_common(1)[0][0]
    horario_freq_dia = Counter(df[df["Dia da Semana"] == dia_freq]["Intervalo"]).most_common(1)[0]
    local_freq_dia = Counter(df[df["Dia da Semana"] == dia_freq]["Local"]).most_common(1)[0]
    horario_local_dia = Counter(df[(df["Dia da Semana"] == dia_freq) & (df["Local"] == local_freq_dia[0])]["Intervalo"]).most_common(1)[0]
    local_geral = contagem_local.most_common(1)[0]
    horario_local_geral = Counter(df[df["Local"] == local_geral[0]]["Intervalo"]).most_common(1)[0]

    analise += f"üìå **Movimenta√ß√£o do ve√≠culo {placa}**\n\n"
    analise += f"- Turno mais frequente: **{contagem_turno.most_common(1)[0][0]}**\n"
    analise += f"- Hor√°rio mais frequente: **{contagem_horario.most_common(1)[0][0]}**\n\n"
    analise += f"- Dia mais frequente: **{dia_freq}**\n"
    analise += f"   - Melhor hor√°rio nesse dia: **{horario_freq_dia[0]}**\n"
    analise += f"   - Local mais frequente nesse dia: **{local_freq_dia[0]}**\n"
    analise += f"   - Melhor hor√°rio nesse local: **{horario_local_dia[0]}**\n\n"
    analise += f"- Local mais frequente geral: **{local_geral[0]}**\n"
    analise += f"   - Melhor hor√°rio nesse local: **{horario_local_geral[0]}**\n\n"

    for i, (dados, titulo) in enumerate([(contagem_turno, "Turnos"), (contagem_horario, "Hor√°rios"), (contagem_dia, "Dias"), (contagem_local, "Locais")]):
        dados = dict(sorted(dados.items(), key=lambda x: x[1], reverse=True))
        if titulo == "Locais":
            dados = dict(list(dados.items())[:10])
        fig, ax = plt.subplots(figsize=(8, 4))
        sns.barplot(x=list(dados.keys()), y=list(dados.values()), ax=ax, palette="dark:blue_r")
        ax.set_title(titulo)
        plt.xticks(rotation=45)
        buf = BytesIO()
        plt.tight_layout()
        fig.savefig(buf, format="png")
        imagens.append(buf)
        plt.close()
    return analise, imagens


def gerar_pdf_streamlit(df, placa, titulo, analise, imagens):
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.utils import ImageReader
    from io import BytesIO

    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    c.setFont("Helvetica-Bold", 12)
    c.drawString(50, 750, titulo)

    y = 720
    for buf in imagens:
        buf.seek(0)
        c.drawImage(ImageReader(buf), 50, y - 100, width=400, height=100)
        y -= 120
        if y < 100:
            c.showPage()
            y = 750

    c.showPage()
    c.setFont("Helvetica", 10)
    y = 750

    
    for linha in analise.split("\n"):
        c.drawString(50, y, linha)
        y -= 15
        if y < 50:
            c.showPage()
            y = 750

    c.save()
    buffer.seek(0)
    return buffer


if __name__ == "__main__":
    main()

Adicione a esse c√≥digo da aplica√ß√£o.
Vou adicionar a funcionalidade de compara√ß√£o facial ao seu c√≥digo existente, criando uma nova p√°gina no menu de navega√ß√£o. Aqui est√° a vers√£o integrada:

python
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from collections import Counter
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.lib.utils import ImageReader
import re, os
from io import BytesIO
import cv2
import numpy as np
import insightface
from insightface.app import FaceAnalysis
from scipy.spatial.distance import cosine
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE

sns.set(style="darkgrid")

dias_semana = {
    "Monday": "Segunda-feira", "Tuesday": "Ter√ßa-feira", "Wednesday": "Quarta-feira",
    "Thursday": "Quinta-feira", "Friday": "Sexta-feira", "Saturday": "S√°bado", "Sunday": "Domingo"
}

# Inicializar o modelo InsightFace
@st.cache_resource
def load_face_model():
    app = FaceAnalysis()
    app.prepare(ctx_id=0, det_size=(640, 640))
    return app

app = load_face_model()

def main():
    st.set_page_config(layout="wide")
    st.sidebar.title("Navega√ß√£o")
    pagina = st.sidebar.radio("Escolha uma op√ß√£o:", 
                             ["üöóüöó - Ve√≠culos em Comboio", 
                              "üïµÔ∏è - An√°lise de Passagens",
                              "üë• - Compara√ß√£o Facial"])

    if pagina == "üöóüöó - Ve√≠culos em Comboio":
        veiculos_em_comboio()
    elif pagina == "üïµÔ∏è - An√°lise de Passagens":
        analise_de_passagens()
    elif pagina == "üë• - Compara√ß√£o Facial":
        comparacao_facial()

# -------------------------------------------
# P√°gina 3 ‚Äì Compara√ß√£o Facial
# -------------------------------------------
def comparacao_facial():
    st.title("üë• Compara√ß√£o Facial")
    st.write("""
    Fa√ßa upload de duas imagens para comparar os rostos detectados. 
    A aplica√ß√£o mostrar√°:
    - Imagens com bounding boxes nos rostos detectados
    - Similaridade entre os rostos
    - Visualiza√ß√£o dos embeddings em 2D e 3D
    """)

    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("Imagem 1")
        img1 = st.file_uploader("Selecione a primeira imagem", type=["jpg", "jpeg", "png"], key="img1")
        
    with col2:
        st.subheader("Imagem 2")
        img2 = st.file_uploader("Selecione a segunda imagem", type=["jpg", "jpeg", "png"], key="img2")

    if img1 and img2:
        processar_comparacao_facial(img1, img2)

def processar_comparacao_facial(img1, img2):
    def extract_face_details(image_file):
        img_bytes = image_file.read()
        img_np = np.frombuffer(img_bytes, np.uint8)
        img = cv2.imdecode(img_np, cv2.IMREAD_COLOR)
        
        if img is None:
            st.error("Erro ao ler a imagem.")
            return None
        
        faces = app.get(img)
        if not faces:
            st.error("Nenhum rosto detectado na imagem.")
            return None
        
        # Desenhar bounding boxes
        img_with_boxes = img.copy()
        for face in faces:
            bbox = face.bbox.astype(int)
            cv2.rectangle(img_with_boxes, (bbox[0], bbox[1]), (bbox[2], bbox[3]), (0, 255, 0), 2)
        
        return {
            'image': img,
            'image_with_boxes': img_with_boxes,
            'faces': faces
        }

    def calculate_similarity(embedding1, embedding2):
        cos_distance = cosine(embedding1, embedding2)
        similarity = (1 - cos_distance) * 100
        similarity = max(min(similarity, 100), 0)
        return similarity

    def plot_embeddings(embeddings, labels):
        embeddings = np.array(embeddings)
        
        # PCA 2D
        pca_2d = PCA(n_components=2)
        embeddings_pca_2d = pca_2d.fit_transform(embeddings)
        
        # t-SNE 2D
        tsne_2d = TSNE(n_components=2, perplexity=min(5, len(embeddings)-1))
        embeddings_tsne_2d = tsne_2d.fit_transform(embeddings)
        
        # Criar figuras
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
        
        # Plot PCA 2D
        for i, (x, y) in enumerate(embeddings_pca_2d):
            ax1.scatter(x, y, label=labels[i])
            ax1.text(x, y, f"{i+1}", fontsize=12)
        ax1.set_title('PCA 2D')
        ax1.legend()
        
        # Plot t-SNE 2D
        for i, (x, y) in enumerate(embeddings_tsne_2d):
            ax2.scatter(x, y, label=labels[i])
            ax2.text(x, y, f"{i+1}", fontsize=12)
        ax2.set_title('t-SNE 2D')
        ax2.legend()
        
        st.pyplot(fig)
        
        # PCA 3D se tivermos pelo menos 3 pontos
        if len(embeddings) >= 3:
            fig_3d = plt.figure(figsize=(8, 6))
            ax_3d = fig_3d.add_subplot(111, projection='3d')
            
            pca_3d = PCA(n_components=3)
            embeddings_pca_3d = pca_3d.fit_transform(embeddings)
            
            for i, (x, y, z) in enumerate(embeddings_pca_3d):
                ax_3d.scatter(x, y, z, label=labels[i])
                ax_3d.text(x, y, z, f"{i+1}", fontsize=12)
            
            ax_3d.set_title('PCA 3D')
            ax_3d.legend()
            st.pyplot(fig_3d)

    # Processar imagens
    result1 = extract_face_details(img1)
    result2 = extract_face_details(img2)
    
    if not result1 or not result2:
        return
    
    # Mostrar imagens com bounding boxes
    st.subheader("Rostos Detectados")
    col1, col2 = st.columns(2)
    with col1:
        st.image(cv2.cvtColor(result1['image_with_boxes'], cv2.COLOR_BGR2RGB), 
                caption="Imagem 1 com rostos detectados", use_column_width=True)
    with col2:
        st.image(cv2.cvtColor(result2['image_with_boxes'], cv2.COLOR_BGR2RGB), 
                caption="Imagem 2 com rostos detectados", use_column_width=True)
    
    # Comparar os primeiros rostos de cada imagem
    face1 = result1['faces'][0]
    face2 = result2['faces'][0]
    
    similarity = calculate_similarity(face1.embedding, face2.embedding)
    
    # Resultados da compara√ß√£o
    st.subheader("üìä Resultados da Compara√ß√£o")
    st.metric("Similaridade entre os rostos", f"{similarity:.2f}%")
    
    # Barra de similaridade
    st.progress(int(similarity))
    
    # Interpreta√ß√£o
    if similarity < 60.0:
        st.warning("üë§ As imagens N√ÉO s√£o da mesma pessoa (similaridade abaixo de 60.0%)")
    elif 60.0 <= similarity < 75.0:
        st.info("ü§î As imagens s√£o PROVAVELMENTE da mesma pessoa (similaridade entre 60.0% e 75.0%)")
    else:
        st.success("‚úÖ As imagens S√ÉO da mesma pessoa (similaridade acima de 75.0%)")
    
    # M√©tricas adicionais
    st.write(f"**Dist√¢ncia de cosseno:** {cosine(face1.embedding, face2.embedding):.4f}")
    
    # Visualiza√ß√£o dos embeddings
    st.subheader("üìà Visualiza√ß√£o dos Embeddings")
    
    embeddings = [face1.embedding, face2.embedding]
    labels = ["Imagem 1", "Imagem 2"]
    
    plot_embeddings(embeddings, labels)
    
    # Detalhes t√©cnicos
    with st.expander("üîç Detalhes t√©cnicos"):
        st.write("**Embedding da Imagem 1:**", face1.embedding)
        st.write("**Embedding da Imagem 2:**", face2.embedding)
        st.write("**Dimens√£o dos embeddings:**", len(face1.embedding))
        
        # Matriz de dist√¢ncia
        dist_matrix = np.zeros((2, 2))
        for i in range(2):
            for j in range(2):
                dist_matrix[i, j] = cosine(embeddings[i], embeddings[j])
        
        st.write("**Matriz de dist√¢ncia de cosseno:**")
        st.dataframe(dist_matrix, index=labels, columns=labels)

sns.set(style="darkgrid")

dias_semana = {
    "Monday": "Segunda-feira", "Tuesday": "Ter√ßa-feira", "Wednesday": "Quarta-feira",
    "Thursday": "Quinta-feira", "Friday": "Sexta-feira", "Saturday": "S√°bado", "Sunday": "Domingo"
}

def main():
    st.set_page_config(layout="wide")
    st.sidebar.title("Navega√ß√£o")
    pagina = st.sidebar.radio("Escolha uma op√ß√£o:", ["üöóüöó - Ve√≠culos em Comboio", "üïµÔ∏è - An√°lise de Passagens"])

    if pagina == "üöóüöó - Ve√≠culos em Comboio":
        veiculos_em_comboio()
    elif pagina == "üïµÔ∏è - An√°lise de Passagens":
        analise_de_passagens()


# -------------------------------------------
# P√°gina 1 ‚Äì Ve√≠culos em Comboio
# -------------------------------------------
def veiculos_em_comboio():
    import re
    from collections import defaultdict

    def process_text(text):
        linhas = [linha.strip() for linha in text.split("\n") if linha.strip()]
        placas = defaultdict(list)
        padrao_placa = re.compile(r'[A-Za-z]{3}\d[A-Za-z]\d{2}|[A-Za-z]{3}\d{4}')
        padrao_data_hora = re.compile(r'(\d{2}/\d{2}/\d{4})\s+(\d{2}:\d{2})')
        placa_atual = None

        for linha in linhas:
            if padrao_placa.fullmatch(linha.strip()):
                placa_atual = linha.strip().upper()
            elif placa_atual and (match := padrao_data_hora.search(linha)):
                data, hora = match.groups()
                placas[placa_atual].append(f"{data} {hora}")
        return placas

    def display_results(placas):
        resultado = "## RELAT√ìRIO DE PLACAS:\n\n"
        resultado += f"**Total de placas √∫nicas encontradas:** {len(placas)}\n\n"
        placas_unicas = {p: d for p, d in placas.items() if len(d) == 1}
        placas_repetidas = {p: d for p, d in placas.items() if len(d) > 1}

        if placas_repetidas:
            resultado += "### üö® PLACAS REPETIDAS:\n"
            for placa, registros in sorted(placas_repetidas.items()):
                resultado += f"\n**Placa:** {placa}\n**Quantidade:** {len(registros)} ocorr√™ncias\n**Registros:**\n"
                for registro in sorted(registros):
                    resultado += f"- {registro}\n"
        if placas_unicas:
            resultado += "\n\n### üîπ PLACAS √öNICAS (apareceram apenas uma vez):\n"
            for placa, registros in sorted(placas_unicas.items()):
                resultado += f"\n**Placa:** {placa}\n**Registro:** {registros[0]}\n"
        return resultado

    st.title("Ve√≠culos em Comboio")
    if 'text_blocks' not in st.session_state:
        st.session_state.text_blocks = [""]

    if st.button("‚ûï Adicionar Passagem"):
        st.session_state.text_blocks.append("")

    for i in range(len(st.session_state.text_blocks)):
        st.session_state.text_blocks[i] = st.text_area(
            f"Passagem {i + 1}",
            value=st.session_state.text_blocks[i],
            height=200,
            key=f"text_block_{i}"
        )

    if st.button("Processar"):
        full_text = "\n".join(st.session_state.text_blocks)
        if full_text.strip():
            placas = process_text(full_text)
            results = display_results(placas)
            st.markdown(results)
            st.download_button("‚¨áÔ∏è Baixar Relat√≥rio", data=results, file_name="relatorio_placas.txt", mime="text/plain")


# -------------------------------------------
# P√°gina 2 ‚Äì An√°lise de Passagens
# -------------------------------------------
def analise_de_passagens():
    st.title("An√°lise de Passagens")

    texto = st.text_area("Cole os dados (linha 1: placa, linha 2: t√≠tulo, restante: registros):", height=400)
    if st.button("Processar Registros"):
        if texto:
            processar_analise(texto)
        else:
            st.warning("Por favor, insira o texto antes de processar.")


def processar_analise(texto):
        # Adiciona "0/0" no final do texto se ainda n√£o estiver presente
    if not texto.strip().endswith("0/0"):
        texto = texto + "\n0/0"
    linhas = [linha.strip() for linha in texto.splitlines() if linha.strip()]
    if len(linhas) < 2:
        st.error("Texto deve conter pelo menos duas linhas: placa e t√≠tulo.")
        return

    placa = linhas[0].strip()
    titulo = linhas[1].strip()
    texto_limpo = "\n".join(linhas)

    padrao = re.compile(r'(\d{1,3})?\n?(\d{2}/\d{2}/\d{4})\s+(\d{2}:\d{2})\n([^\n]+)\n([^\n]+)', re.VERBOSE)
    registros = []

    for i, match in enumerate(padrao.finditer(texto_limpo)):
        velocidade, data, horario, local, _ = match.groups()
        cidade = local.split(',')[-1].split('-')[0].strip() if ',' in local and '-' in local else local
        data_formatada = datetime.strptime(data, "%d/%m/%Y")
        hora = int(horario.split(":")[0])
        turno = "Manh√£" if 0 <= hora < 12 else "Tarde" if hora < 18 else "Noite"
        dia_semana = dias_semana[data_formatada.strftime("%A")]
        intervalo = f"{hora}:00 - {hora+1}:00"
        registros.append([i + 1, velocidade or "", data, horario, turno, dia_semana, intervalo, local, cidade])

    if not registros:
        st.error("Nenhum registro v√°lido encontrado.")
        return

    df = pd.DataFrame(registros, columns=["Ord", "Velocidade", "Data", "Hor√°rio", "Turno", "Dia da Semana", "Intervalo", "Local", "Cidade"])
    st.success(f"{len(df)} registros processados.")
    st.dataframe(df)

    # Gera√ß√£o Excel
    excel_buffer = BytesIO()
    df.to_excel(excel_buffer, index=False)
    st.download_button("‚¨áÔ∏è Baixar Excel", data=excel_buffer.getvalue(), file_name=f"{placa}.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

    # Gera√ß√£o da an√°lise textual e PDF
    analise, imagens = gerar_analise(df, placa)
    st.markdown(analise)

    pdf_buffer = gerar_pdf_streamlit(df, placa, titulo, analise, imagens)
    st.download_button("‚¨áÔ∏è Baixar PDF", data=pdf_buffer.getvalue(), file_name=f"analise_{placa}.pdf", mime="application/pdf")


def gerar_analise(df, placa):
    analise = ""
    imagens = []
    contagem_turno = Counter(df["Turno"])
    contagem_horario = Counter(df["Intervalo"])
    contagem_dia = Counter(df["Dia da Semana"])
    contagem_local = Counter(df["Local"])

    dia_freq = contagem_dia.most_common(1)[0][0]
    horario_freq_dia = Counter(df[df["Dia da Semana"] == dia_freq]["Intervalo"]).most_common(1)[0]
    local_freq_dia = Counter(df[df["Dia da Semana"] == dia_freq]["Local"]).most_common(1)[0]
    horario_local_dia = Counter(df[(df["Dia da Semana"] == dia_freq) & (df["Local"] == local_freq_dia[0])]["Intervalo"]).most_common(1)[0]
    local_geral = contagem_local.most_common(1)[0]
    horario_local_geral = Counter(df[df["Local"] == local_geral[0]]["Intervalo"]).most_common(1)[0]

    analise += f"üìå **Movimenta√ß√£o do ve√≠culo {placa}**\n\n"
    analise += f"- Turno mais frequente: **{contagem_turno.most_common(1)[0][0]}**\n"
    analise += f"- Hor√°rio mais frequente: **{contagem_horario.most_common(1)[0][0]}**\n\n"
    analise += f"- Dia mais frequente: **{dia_freq}**\n"
    analise += f"   - Melhor hor√°rio nesse dia: **{horario_freq_dia[0]}**\n"
    analise += f"   - Local mais frequente nesse dia: **{local_freq_dia[0]}**\n"
    analise += f"   - Melhor hor√°rio nesse local: **{horario_local_dia[0]}**\n\n"
    analise += f"- Local mais frequente geral: **{local_geral[0]}**\n"
    analise += f"   - Melhor hor√°rio nesse local: **{horario_local_geral[0]}**\n\n"

    for i, (dados, titulo) in enumerate([(contagem_turno, "Turnos"), (contagem_horario, "Hor√°rios"), (contagem_dia, "Dias"), (contagem_local, "Locais")]):
        dados = dict(sorted(dados.items(), key=lambda x: x[1], reverse=True))
        if titulo == "Locais":
            dados = dict(list(dados.items())[:10])
        fig, ax = plt.subplots(figsize=(8, 4))
        sns.barplot(x=list(dados.keys()), y=list(dados.values()), ax=ax, palette="dark:blue_r")
        ax.set_title(titulo)
        plt.xticks(rotation=45)
        buf = BytesIO()
        plt.tight_layout()
        fig.savefig(buf, format="png")
        imagens.append(buf)
        plt.close()
    return analise, imagens


def gerar_pdf_streamlit(df, placa, titulo, analise, imagens):
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.utils import ImageReader
    from io import BytesIO

    buffer = BytesIO()
    c = canvas.Canvas(buffer, pagesize=letter)
    c.setFont("Helvetica-Bold", 12)
    c.drawString(50, 750, titulo)

    y = 720
    for buf in imagens:
        buf.seek(0)
        c.drawImage(ImageReader(buf), 50, y - 100, width=400, height=100)
        y -= 120
        if y < 100:
            c.showPage()
            y = 750

    c.showPage()
    c.setFont("Helvetica", 10)
    y = 750

    
    for linha in analise.split("\n"):
        c.drawString(50, y, linha)
        y -= 15
        if y < 50:
            c.showPage()
            y = 750

    c.save()
    buffer.seek(0)
    return buffer


if __name__ == "__main__":
    main()
